
<html lang="en">
	<head>
		<title>culture heritage viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

	</head>
	<body>

 <script src="modules/FileSaver.js"></script>
		<div id="info">
			3D view
		</div>
		<div id="info2">
			2D view
		</div>
		<div class=container4 id="loadingTextContainer">
		  <p id="loadingText">Loading: 0% 
		</div>

		<script id="vertexShaderSprite" type="x-shader/x-fragment" >
			varying vec2 vUv;

		    void main() {
		    	vUv = uv;
		      gl_Position =   projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);

		    }</script>
		<script id="fragmentShaderSprite" type="x-shader/x-fragment">
			uniform vec2 minSel; 
			uniform vec2 maxSel; 
			uniform sampler2D texture1;
			uniform float opacity;

			varying vec2 vUv;
			float borderSel = 0.015;
			void main() {

				if(vUv.x > 0.98 || vUv.x < 0.02 || vUv.y > 0.98 || vUv.y < 0.02)
				{
					gl_FragColor = vec4(0.0,0.0,0.0,1.0);
				}
				else
				{
					vec4 color;
					if(minSel != maxSel && (
						(vUv.x > minSel.x && vUv.x < minSel.x+borderSel && vUv.y > minSel.y && vUv.y < maxSel.y+borderSel) ||
						(vUv.y > minSel.y && vUv.y < minSel.y+borderSel && vUv.x > minSel.x && vUv.x < maxSel.x+borderSel) ||
						(vUv.x > maxSel.x && vUv.x < maxSel.x+borderSel && vUv.y > minSel.y && vUv.y < maxSel.y+borderSel) ||
						(vUv.y > maxSel.y && vUv.y < maxSel.y+borderSel && vUv.x > minSel.x && vUv.x < maxSel.x+borderSel)
						))
					{
						color = vec4(1.0,0.0,0.0,1.0);
					}
					else
					{
						color = texture2D(texture1, vUv); 
						
					}
					color.a = opacity;
					gl_FragColor = color;
					
				}
			}</script>
		<script id="vertexShaderScene" type="x-shader/x-fragment">
			varying vec2 vUv; 
		    varying vec3 capturePos;
		    varying vec4 modelViewPosition; 
		    varying vec3 vecNormal;
		    uniform mat4 viewMatrixCapture;
		    uniform mat4 projectionMatrixCapture;

		    void main() {
		    	vUv = uv;
		    	vec4 auxCapture = projectionMatrixCapture * viewMatrixCapture * modelMatrix* vec4(position,1.0);
		    	capturePos = vec3(auxCapture.x/auxCapture.w,auxCapture.y/auxCapture.w,auxCapture.z/auxCapture.w);
		    	//capturePos =   (projectionMatrixCapture *  modelViewMatrix * vec4(position,1.0)).xyz;
		      //vUv = position; 
		      //vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
		      //vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz; //????????
		      //gl_Position = projectionMatrix * modelViewPosition; 
		      gl_Position =   projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);
		      
		      //gl_Position = capturePos;
		    }</script>
		<script id="fragmentShaderScreen" type="x-shader/x-fragment">

			varying vec2 vUv;
			uniform sampler2D tDiffuse;

			void main() {

				gl_FragColor = texture2D( tDiffuse, vUv );

			}</script>
		<script id="fragmentShaderCaptureImage" type="x-shader/x-fragment">
			uniform sampler2D texture1;
			uniform bool showTexture;

			varying vec2 vUv;
			varying vec3 capturePos;
			void main() {
			  //gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
			  //if(capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > 0.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  if(showTexture && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0)
			  {
			  		vec2 texCoords = vec2((capturePos.x+1.0f)/2.0f,(capturePos.y+1.0f)/2.0f);
			  		gl_FragColor = texture2D(texture1, texCoords);
			  }
			  else 
			  {
			  	discard;
					//gl_FragColor = texture2D(texture1, vUv); 
					//discard;
			  }

			}</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform sampler2D texture1;
			uniform sampler2D texture2;
			uniform bool showRedArea;
			uniform bool projectCapture;
			varying vec2 vUv;
			varying vec3 capturePos;
			void main() {
			  //gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
			  //if(capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > 0.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  if(showRedArea && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  {

			  	if(capturePos.x < -0.95 || capturePos.x > 0.95 || capturePos.y < -0.95 || capturePos.y > 0.95)
			  		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.6), 1.0);
			  	else
			  		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.8), 1.0);
			  }
			  else 
			  {
			  	if(projectCapture && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  	{
			  		vec2 texCoords = vec2((capturePos.x+1.0f)/2.0f,(capturePos.y+1.0f)/2.0f);
			  		gl_FragColor = texture2D(texture2, texCoords);
			  	}
			  	else
			  	{
			  		gl_FragColor = texture2D(texture1, vUv); 
			  	}
					
					//discard;
			  }

			  
			   
			}</script>
		<script src="scripts/globals.js"></script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			
			import { PLYLoader } from './jsm/loaders/PLYLoader.js';

			import { OrbitControls } from './jsm/controls/CustomOrbitControls.js';
			//import { FlyControls } from './jsm/controls/FlyControls.js';
			//import { TrackballControls } from './jsm/controls/CustomTrackballControls.js';
			import { SelectionBox } from './jsm/interactive/SelectionBox.js';
			import { SelectionHelper } from './jsm/interactive/SelectionHelper.js';
			import { VRButton } from './jsm/webxr/VRButton.js';
			import { XRControllerModelFactory } from './jsm/webxr/XRControllerModelFactory.js';
			import { DataLoader } from './scripts/DataLoader.js';
			import { compareSimilitudes, compareCandidates, compareCanditateIndices} from './scripts/compareFuncs.js';
			import { getWorldIntersectFromNDCxy, getNDCposFromWorld, positionAtT, getWorldFromNDC} from './scripts/utils.js';

			import { ModelInfo} from './scripts/ModelInfo.js';
			import { CameraInfo} from './scripts/CameraInfo.js';
			import { GUI } from './../jsm/libs/dat.gui.module.js';
			//import { Application} from './scripts/Application.js';
			import { Gui} from './scripts/Gui.js';
			//import { saveAs } from './modules/FileSaver.js';

			const m_clock = new THREE.Clock();
			var m_manager = new THREE.LoadingManager();

			var m_old_pos_cam =  new THREE.Vector3();

			init();

			

			function moveToCapturePosition(index_capture)
			{
				var captureCam = m_camera_list[index_capture].camera
				var direction = new THREE.Vector3();
				captureCam.getWorldDirection( direction );
				m_camera.position.copy( captureCam.position )
				
				var v1 = new THREE.Vector3(); // create once and reuse it
				
				m_controls.update()
				
				m_controls.target = new THREE.Vector3( captureCam.position.x+direction.x, captureCam.position.y+direction.y, captureCam.position.z+direction.z );
				//m_controls_secondary.target = new THREE.Vector3( captureCam.position.x, captureCam.position.y, captureCam.position.z );
				//m_controls_secondary.update()
				m_controls.update()
			}


			function changeCaptureInView(index_capture)
			{
				m_has_any_secondary_capture = true
				var directionCapture = new THREE.Vector3();
				var v1 = new THREE.Vector3();
				m_camera_list[index_capture].camera.getWorldDirection( directionCapture );
				var positionCapture = new THREE.Vector3();
				positionCapture.copy(m_camera_list[index_capture].camera.position);
				
				/*m_camera_capture.position.set( positionCapture.x,positionCapture.y,positionCapture.z );

				v1.copy( m_camera_list[index_capture].mesh.up ).applyQuaternion( m_camera_list[index_capture].mesh.quaternion );
				m_camera_capture.quaternion.copy( m_camera_list[index_capture].mesh.quaternion );
				m_camera_capture.up.set(v1.x, v1.y, v1.z); 
				*/

				m_camera_capture.copy(m_camera_list[index_capture].camera,true)


				//TODO: GET THIS VALUE FROM FILE:
				m_camera_capture.aspect = m_camera_list[index_capture].width / m_camera_list[index_capture].height;
				m_camera_capture.updateMatrixWorld();
				m_camera_capture.updateProjectionMatrix();
				var viewMat = new THREE.Matrix4();
				var projMat = new THREE.Matrix4();

				var texture_low, material, plane, plane_rt;

				texture_low = THREE.ImageUtils.loadTexture( "models/"+m_models_values[m_gui.gui_options.current_model].path+"/thumbnails/"+m_camera_list[index_capture].name );

				viewMat.copy(m_camera_capture.matrixWorldInverse);
				projMat.copy(m_camera_capture.projectionMatrix)
				m_scene_models[0].material.uniforms.viewMatrixCapture.value = viewMat;
				m_scene_models[0].material.uniforms.projectionMatrixCapture.value = projMat;
				m_scene_models[0].material.uniforms.texture2.value = texture_low;
				m_camera_capture.fov = m_camera_list[index_capture].camera.fov+30


				const loader = new THREE.TextureLoader();
				var tex_name = m_camera_list[index_capture].name
				loader.load(
					// resource URL
					"models/"+m_models_values[m_gui.gui_options.current_model].path+"/captures/"+m_camera_list[index_capture].name,

					// onLoad callback
					function ( texture_high ) {
						// in this example we create the material when the texture is loaded
						if(m_camera_capture.name == tex_name)
						{
							//console.log(m_camera_capture.name + " "+tex_name)
							if(m_scene_models.length >0)
								m_scene_models[0].material.uniforms.texture2.value = texture_high;
							if(m_plane_image_secondary != null)
								m_plane_image_secondary.material.uniforms.texture1.value = texture_high;
						}
						
					},
					// onError callback
					function ( err ) {
						console.error( 'Error trying to load texture (high res) for capture.' );
					}
				);

				var frustumHeightWorld_photo = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_list[index_capture].camera.fov * 0.5 ));
				var frustumHeightWorld_view = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
				var scaleFact = frustumHeightWorld_view/frustumHeightWorld_photo;
				m_camera_capture.render_target_height = m_camera_list[index_capture].height*scaleFact
				m_camera_capture.render_target_width = m_camera_capture.render_target_height * m_camera_capture.aspect

				//m_render_target_secondary = new THREE.WebGLRenderTarget(m_camera_capture.render_target_width, m_camera_capture.render_target_height);
				m_render_target_secondary.setSize(m_camera_capture.render_target_width, m_camera_capture.render_target_height)

				//TODO: do this init once
				let uniforms = {
					  viewMatrixCapture: {type: 'mat4', value: viewMat},
					  projectionMatrixCapture: {type: 'mat4', value: projMat},
				        showTexture: {type: 'bool', value: true},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: texture_low }
				    }
				const material_plane = new THREE.ShaderMaterial( { 
						uniforms: uniforms,
					    fragmentShader: document.getElementById('fragmentShaderCaptureImage').textContent,
					    vertexShader: document.getElementById('vertexShaderScene').textContent,
					    blending: THREE.NormalBlending,
		                depthTest: false,
		                transparent: true
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );

				
				plane = new THREE.Mesh(new THREE.PlaneGeometry(1.0001, 1.0001), material_plane);
				plane.name ="plane_photo"
				plane.translateZ( -(m_camera_capture.near+0.0001) );
				if(m_plane_image_secondary != null)
				{
					var existing = m_scene.getObjectByName("plane_photo");
					if(existing)
						m_scene.remove( existing );
				}
				plane.applyMatrix(m_camera_capture.matrix)
				m_plane_image_secondary = plane;
				m_scene.add(m_plane_image_secondary)



				
				const material_plane_rt = new THREE.ShaderMaterial( { 
						uniforms: {tDiffuse: {value: m_render_target_secondary.texture}},
					    fragmentShader: document.getElementById('fragmentShaderScreen').textContent,
					    vertexShader: document.getElementById('vertexShaderSprite').textContent,
					    depthWrite: false
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );

				plane_rt = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material_plane_rt);
				plane_rt.name ="plane_rt"
				plane_rt.position.z = -1
				m_plane_render_target = plane_rt

				if(m_plane_render_target != null)
				{
					var existing = m_scene_capture.getObjectByName("plane_rt");
					if(existing)
						m_scene_capture.remove( existing );
					//m_scene_capture.remove(m_plane_render_target)
				}
				m_scene_capture.add(m_plane_render_target)

				m_controls_secondary.reset();

			}
			function selectCapture(index_capture, allow_jump = false)
			{
				//var index_capture = m_current_candidates[index_candidate].index;
				if(m_current_capture_in_view_index == index_capture && allow_jump)
				{
					moveToCapturePosition(index_capture)
				}
				else
				{
					if(index_capture !=m_current_capture_in_view_index)
					changeCaptureInView(index_capture)
				}
				m_current_capture_in_view_index = index_capture;
				
			}



			function showCollectionSprite(_min_pos, _max_pos, index_capture, order, sprites_to_remove = [], isShifting = false, opacity = 1)
			{
				var min_pos, max_pos, offset_x, offset_y;
				if(m_renderer.xr.isPresenting)
				{
					//var hardcodedHeight = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
					//var hardcodedWidth = frustumHeight * m_camera_capture.aspect;
					var hardcodedHeight = 2 * 4 * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
					var hardcodedWidth = hardcodedHeight * m_camera_capture.aspect;
					var scaleFx = hardcodedWidth/window.innerWidth
					var scaleFy = hardcodedHeight/window.innerHeight
					/*min_pos = getWorldFromNDC(m_camera, _min_pos)
					max_pos = getWorldFromNDC(m_camera, _max_pos)*/
					min_pos = new THREE.Vector3(_min_pos.x*scaleFx,_min_pos.y*scaleFy,0);
					max_pos = new THREE.Vector3(_max_pos.x*scaleFx,_max_pos.y*scaleFy,0);
					console.log(min_pos)
					console.log(max_pos)
					offset_x = -hardcodedWidth/2;
					offset_y = hardcodedHeight/2
				}
				else{
					min_pos = new THREE.Vector3(_min_pos.x,_min_pos.y,0);
					max_pos = new THREE.Vector3(_max_pos.x,_max_pos.y,0);
					offset_x = -window.innerWidth/2;
					offset_y = window.innerHeight/2
				}
				
				var scale1 = (max_pos.x -min_pos.x)/m_camera_list[index_capture].width;
				var scale2 = (max_pos.y -min_pos.y)/m_camera_list[index_capture].height;
				var scale = Math.min(scale1, scale2);
				var sprite = m_camera_list[index_capture].sprite;
				var existing = m_scene_collections.getObjectByName(sprite.name);
				var _x = min_pos.x+offset_x
				var _y = min_pos.y+offset_y
				var spritepos = new THREE.Vector3(_x,_y,0);
				if(m_renderer.xr.isPresenting)
				{
					spritepos.z = -order*0.25
				}
				//var spritepos = new THREE.Vector3(0,0,1);

				//sprite.center.set(0,1)
				sprite.scale.set(m_camera_list[index_capture].width*scale, m_camera_list[index_capture].height*scale, 1);
				sprite.position.set(spritepos.x+(m_camera_list[index_capture].width*scale)/2,spritepos.y-(m_camera_list[index_capture].height*scale)/2, spritepos.z);
				if(m_renderer.xr.isPresenting)
				{
					sprite.renderOrder = -order;
				}
				else
				{
					sprite.renderOrder = order;
				}
				
				sprite.name = index_capture;
				//sprite.material.opacity = opacity;
				sprite.material.uniforms.opacity.value = opacity;
				if(!isShifting)
				{
					//m_scene_collections.add(sprite);

					m_current_sprites_in_scene.add(sprite)
				}

				if(sprites_to_remove.length > 0)
				{
					const index = sprites_to_remove.indexOf(sprite.name);
					if (index > -1) {
					  sprites_to_remove.splice(index, 1);
					}
				}	
			}

			function showCollection(min_pos, max_pos, index_collection, sprites_to_remove = [], isShifting = false, offsetAnim = 0)
			{
				var animOffset = 0;
				if(offsetAnim > 0)
				{
					animOffset = 1-offsetAnim;
				} else if(offsetAnim < 0)
				{
					animOffset = -(offsetAnim+1);
				}
				var currentOffset = new THREE.Vector2(5+animOffset*5,5+animOffset*5)
				var remaining_width = max_pos.x-min_pos.x-currentOffset.x;
				var remaining_height = max_pos.y-min_pos.y-currentOffset.y;
				var offset_per_image = 10;
				var num_elems = m_current_candidates_collections[index_collection].elems.length
				var width_image = remaining_width-num_elems*offset_per_image
				var height_image = remaining_height-num_elems*offset_per_image
				for(var i = num_elems-1; i >= 0; i--)
				{
					var min = new THREE.Vector3( min_pos.x+currentOffset.x, min_pos.y-currentOffset.y,-1 );
					var max = new THREE.Vector3( min_pos.x+currentOffset.x+width_image+animOffset*5 ,min_pos.y+currentOffset.y+height_image+animOffset*5,-1);
					currentOffset.x = currentOffset.x + offset_per_image;
					currentOffset.y = currentOffset.y + offset_per_image;
					var opacity = 1
					if(animOffset > 0 && i == 0)
					{
						opacity = 1 - animOffset
					} else if(animOffset < 0 && i == num_elems-1)
					{
						opacity = 1 - animOffset*(-1)
					}
						
					showCollectionSprite(min, max, m_current_candidates_collections[index_collection].elems[i],num_elems-i,sprites_to_remove, isShifting, opacity)
				}
				
			}

			function showCollections()
			{
				var remaining_width = window.innerWidth-200;
				var current_min_x = 0;
				var collection_height = 500
				var sprites_to_remove = []
				

				for(var i = 0; i < m_current_sprites_in_scene.children.length; i++)
				{
					sprites_to_remove.push(m_current_sprites_in_scene.children[i].name)
				}
				while(m_current_sprites_in_scene.children.length > 0){ 
				    m_current_sprites_in_scene.remove(m_current_sprites_in_scene.children[0]); 
				}
				for(var i = 0; i < m_current_candidates_collections.length; i++)
				{
					var collection_width = remaining_width/4
					var min = new THREE.Vector2( current_min_x, 0 );
					var max = new THREE.Vector2(current_min_x+ collection_width,collection_height);
					m_current_candidates_collections[i].min = min;
					m_current_candidates_collections[i].max = max;
					showCollection(min,max,i, sprites_to_remove);
					remaining_width = remaining_width - collection_width;
					current_min_x = current_min_x + collection_width;
				}
				//console.log(m_current_candidates_collections.length)
				//console.log(sprites_to_remove)
				/*for(var i = 0; i < sprites_to_remove.length; i++)
				{
					var existing = m_scene_collections.getObjectByName(sprites_to_remove[i]);
					if(existing)
						m_scene_collections.remove( existing );

				}*/

			}


			
			function getCaptureUnderMouse(event)
			{
	            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );     
	            var raycaster =  new THREE.Raycaster();                                        
	           raycaster.setFromCamera( mouse3D, m_camera_collections );
	            var intersects = raycaster.intersectObjects( m_current_sprites_in_scene.children );
				//console.log(intersects)
				//setDefaultColorsCameras();

	            if ( intersects.length > 0 ) 
	            {
	            	var curr_index = intersects[ 0 ].object.name
	            	var curr_depth = intersects[ 0 ].object.renderOrder
	            	for(var i=0; i <intersects.length; i++)
	            	{
	            		if(intersects[ i ].object.renderOrder > curr_depth)
	            		{
	            			curr_depth = intersects[ i ].object.renderOrder;
	            			curr_index = intersects[ i ].object.name;
	            		}
	            	}
	            	return curr_index
	            }
	            else
	            	return -1
			}
			function getCollectionIndexUnderMouse(event)
			{
				if(m_application_state.capture_index_over_mouse != -1)
				{
					var index_collection = -1
					for(var i=0; i<m_current_candidates_collections.length; i++)
					{
						for(var j=0; j < m_current_candidates_collections[i].elems.length; j++)
						{
							if(m_current_candidates_collections[i].elems[j] == m_application_state.capture_index_over_mouse)
							{
								index_collection = i;
								break;
							}
						}
						
					}
					return index_collection;
				}
				return -1;
			}
			function onDocumentKeyDown(event) {
				if(m_application_state.state == AppStates.READY_TO_GO)
				{
					var keyCode = event.which;
				    if (keyCode == 82) { //R
				        resetCamera("ORBIT");
				    /*} else if (keyCode == 77) { //M
				        changeMode();*/
				    /*}  else if (keyCode == 67) { //C
				        toggleEnableCams();*/
				    }  else if (keyCode == 17) {
				    	m_application_state.select_controls_enabled = true;
				    	m_controls.enabled = false;
				    	m_controls_secondary.enabled = false;
				    	m_selection_rectangle.helper.element.hidden = false;
				    	
				    	/*m_canvas.setHeight(window.innerHeight);
						m_canvas.setWidth(window.innerWidth);*/
				    }
				}
			};


			


			function onDocumentPointerMove(event)
			{
				if(!m_application_state.state == AppStates.READY_TO_GO)
					return;
				var captureIndex = getCaptureUnderMouse(event);
				if(captureIndex >= 0)
				{
					//console.log("mouse move, capture: "+ captureIndex)
					if(m_application_state.capture_index_over_mouse != captureIndex && !m_application_state.select_controls_enabled)
						selectCapture(captureIndex)
					m_application_state.capture_index_over_mouse = captureIndex;
					if(m_controls)
						m_controls.enabled = false;
					if(m_controls_secondary)
						m_controls_secondary.enabled = false;
				}
				else
				{
					if(!m_application_state.select_controls_enabled && !m_application_state.views_swaped)
					{
						if(m_controls)
							m_controls.enabled = true;
					}
						
					if(m_controls_secondary && m_application_state.views_swaped)
						m_controls_secondary.enabled = true;
					m_application_state.capture_index_over_mouse = -1;
				}
					
				if(m_application_state.select_controls_enabled && m_dragging)
				{
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
				                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
				                                    0.5 );   
					m_selection_rectangle.endNDC = mouseNDC

					m_selection_rectangle.selectionBox.endPoint.set(
									( event.clientX / window.innerWidth ) * 2 - 1,
									- ( event.clientY / window.innerHeight ) * 2 + 1,
									0.5 );
				}
				else
				{

				}
			}
			function onDocumentPointerDown(event)
			{
				if(!m_application_state.state == AppStates.READY_TO_GO)
				return;
				if(m_application_state.select_controls_enabled)
				{
					//document.getElementById("selection_menu").style.display = "none";
					

					m_gui.disableGui()
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
				                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
				                                    0.5 );   
					
					m_selection_rectangle.startNDC = mouseNDC
					m_selection_rectangle.endNDC = mouseNDC
					var auxNDC = new THREE.Vector2(mouseNDC.x, mouseNDC.y);

					
					//console.log("NDC down" + mouseNDC);
					m_dragging = true;

					m_selection_rectangle.selectionBox.startPoint.set(
								( event.clientX / window.innerWidth ) * 2 - 1,
								- ( event.clientY / window.innerHeight ) * 2 + 1,
								0.5 );
				}
				else
				{
					if(m_gui.gui_options.show_view_enabled)
					{
						var mouseWindwNorm = new THREE.Vector3( ( event.clientX / window.innerWidth ),   
				                                    1-( event.clientY / window.innerHeight ),  
				                                    0.5 );   
						

						console.log(mouseWindwNorm)
						if(mouseWindwNorm.x >m_views[1].left && mouseWindwNorm.x < m_views[1].left +m_views[1].width && mouseWindwNorm.y >m_views[1].bottom && mouseWindwNorm.y <m_views[1].bottom+m_views[1].height)
						{
							m_application_state.views_swaped = !m_application_state.views_swaped;
							if(m_application_state.views_swaped)
							{
								document.getElementById("info").innerHTML  = "2D view";
								document.getElementById("info2").innerHTML  = "3D view";
								m_controls_secondary.enabled = true;
								m_controls_secondary.update()
								m_controls.enabled = false;
								console.log("SET TO FALSE NEN")
							}
							else
							{
								document.getElementById("info").innerHTML  = "3D view";
								document.getElementById("info2").innerHTML  = "2D view";
								m_controls_secondary.enabled = false;
								m_controls.enabled = true;
								console.log("SET TO TRU NEN")
							}
						}
					}
					

				}
			}

			function onDocumentMouseWheel(event)
			{
				var collection = getCollectionIndexUnderMouse(event)
				if(collection >=0 && m_current_candidates_collections[collection].elems.length > 1)
				{
					if(event.wheelDelta > 0)
					{
						m_current_candidates_collections[collection].animating = 1
					}
					else
					{
						m_current_candidates_collections[collection].animating = -1
					}
				}

			}
			function onDocumentPointerUp( event ) {   
				if(!m_application_state.state == AppStates.READY_TO_GO)
					return;
				if(m_application_state.select_controls_enabled)
				{
					m_gui.enableGui()
					m_dragging = false;
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );   
					m_selection_rectangle.endNDC = mouseNDC

					m_selection_rectangle.selectionBox.endPoint.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1,
					0.5 );

					updateCandidates(true);
				}
				else
				{
					var captureIndex = getCaptureUnderMouse(event);
					if(captureIndex >= 0)
						selectCapture(captureIndex, true)
				}
	        }


	        function setDefaultColorsCameras()
	        {

	        	var arrayLength = m_camera_list.length;
				for (var i = 0; i < arrayLength; i++) {
				    m_camera_list[i].mesh.material.color.setHex( 0xffffff );
				    m_camera_list[i].mesh.material.opacity = 0.0; 
				    //Do something
				}
	        }
			function loadCamera(element, index, array)
			{
				
				//https://github.com/colmap/colmap/issues/797
				//https://github.com/colmap/colmap/issues/572
				console.log("      Loading Camera "+element.name+" ...")
				 /*const loader = new PLYLoader();
				 loader.load( './assets/camera.ply', function ( geometry ) {*/

				 	var m = new THREE.Matrix4();
					m.set( element.m1, element.m2, element.m3, element.tx,
			           element.m4, element.m5, element.m6, element.ty,
			           element.m7, element.m8, element.m9, element.tz,
			           0, 0, 0, 1 );
					m.invert();

					
					//const mesh = new THREE.m_vr_move_utils.LineSegments( geometry, material );
					//const mesh = new THREE.m_vr_move_utils.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } ) );
					var m2 = new THREE.Matrix4();

					m2.makeRotationX(THREE.Math.degToRad(-90))
					m2.multiply(m)

					// START MESH
					/*
					geometry.computeVertexNormals();
					const edges = new THREE.EdgesGeometry( geometry );
					//const material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
					const material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );

					material.transparent = true;
					material.opacity = 0.3; 
					const mesh = new THREE.Mesh( geometry, material );
					mesh.applyMatrix4(m2);
					mesh.castShadow = false;
					mesh.receiveShadow = false;
					mesh.material.opacity = 0.0; 
					mesh.name = "cam-"+element.name
					*/
					//END MESH



					var fov_y = 2*Math.atan(element.height/(2*element.f))
					var fov_x = 2*Math.atan(element.width/(2*element.f))


					//console.log("FOVS: "+fov_y + " "+fov_x)
					var capture_camera = new THREE.PerspectiveCamera( fov_y*(180/Math.PI), element.width / element.height, 0.1, 100 );

					capture_camera.applyMatrix4(m2);
					//capture_camera.position.set( mesh.position.x,mesh.position.y,mesh.position.z );
					capture_camera.name = element.name
						/////////////

						//capture_camera.setFocalLength(element.f*(180/3.14))
						//var v1 = new THREE.Vector3();
					/*v1.copy(mesh.up ).applyQuaternion(mesh.quaternion );
					capture_camera.quaternion.copy(mesh.quaternion );
					capture_camera.up.set(v1.x, v1.y, v1.z); */

					//capture_camera.aspect = element.width/element.height;

					capture_camera.updateMatrixWorld();
					capture_camera.updateProjectionMatrix();
					
					////////////////////////

					const texture_sprite = new THREE.TextureLoader().load( 'models/'+m_models_values[m_gui.gui_options.current_model].path+'/thumbnails/'+element.name);
					//const material_sprite = new THREE.SpriteMaterial( { map: texture_sprite } );

					let uniformsSprite = {
				        minSel: {type: 'vec2', value: new THREE.Vector2(0,0)},
				        maxSel: {type: 'vec2', value: new THREE.Vector2(0,0)},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: texture_sprite },
				        opacity: {type: 'f', value: null },

				    }
					const material_sprite = new THREE.ShaderMaterial( { 
						uniforms: uniformsSprite,
					    fragmentShader: document.getElementById('fragmentShaderSprite').textContent,
					    vertexShader: document.getElementById('vertexShaderSprite').textContent,
					    blending: THREE.NormalBlending,
		                depthTest: false,
		                transparent: true
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );
					var geometry_sprite = new THREE.PlaneGeometry(1,1);
					const sprite = new THREE.Mesh(geometry_sprite, material_sprite);

					


					//m_scene.add( sprite );


					var new_camera = new CameraInfo(
						element.name,
						element.width,
						element.height,
						m,
						element.f,
						null,//mesh for debug
						sprite,
						capture_camera
					);
					
					m_camera_list.push(new_camera);
					/*var loader2 = new THREE.TextureLoader();
					var texture = loader2.load( "./thumbnails/"+element.name, function ( tex ) {
					    // tex and texture are the same in this example, but that might not always be the case
					    new_camera.width = tex.image.width
					    new_camera.height = tex.image.height
					    capture_camera.aspect = new_camera.width/new_camera.height;
					    //console.log( tex.image.width, tex.image.height );
					    //console.log( texture.image.width, texture.image.height );
					} );*/

					//setDefaultColorsCameras()
					m_application_state.num_cameras_loaded +=1

					var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
					document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";
					if(m_min_pos == null)
					{
						m_min_pos = new THREE.Vector3(capture_camera.position.x,capture_camera.position.y,capture_camera.position.z)
					}
					if(m_max_pos == null)
					{
						m_max_pos = new THREE.Vector3(capture_camera.position.x,capture_camera.position.y,capture_camera.position.z)
					}
					if(m_min_pos.x > capture_camera.position.x)
						m_min_pos.x = capture_camera.position.x
					if(m_min_pos.y > capture_camera.position.z)
						m_min_pos.y = capture_camera.position.z
					if(m_min_pos.z > capture_camera.position.z)
						m_min_pos.z = capture_camera.position.z

					if(m_max_pos.x < capture_camera.position.x)
						m_max_pos.x = capture_camera.position.x
					if(m_max_pos.y < capture_camera.position.z)
						m_max_pos.y = capture_camera.position.z
					if(m_max_pos.z < capture_camera.position.z)
						m_max_pos.z = capture_camera.position.z
					console.log("      Loading Camera "+element.name+" : DONE")
					//console.log("CAMERA LOADED")
					/*
				} );*/

			}
			
			function loadCameras(cameras) {
				m_application_state.num_cameras_to_load = cameras.cameras.length
				console.log("INFO: Loading cameras...")
				cameras.cameras.forEach(loadCamera);
			}
			function loadModel(model)
			{
				console.log("INFO: Loading "+model.path+"...")
				const loader = new PLYLoader();
				const loaderTex = new THREE.TextureLoader(m_manager);



				loader.load( './models/'+model.path+'/meshes/'+model.mesh_name, function ( geometry ) {
					geometry.computeVertexNormals();
					let uniforms = {
				        viewMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        projectionMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        showRedArea: {type: 'bool', value: false},
				        projectCapture: {type: 'bool', value: false},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: loaderTex.load('./models/'+model.path+'/textures/'+m_models_values[m_gui.gui_options.current_model].texture_name) },
				        texture2: { type: "t", value: null },
				    }
					const material = new THREE.ShaderMaterial( { 
						uniforms: uniforms,
					    fragmentShader: document.getElementById('fragmentShader').textContent,
					    vertexShader: document.getElementById('vertexShaderScene').textContent,
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );
					const mesh = new THREE.Mesh( geometry, material );

					var m2 = new THREE.Matrix4();
					m2.makeRotationX(THREE.Math.degToRad(-90))

					mesh.applyMatrix4(m2);
					//mesh.scale.multiplyScalar( 0.03 );
					//mesh.rotation.x = - Math.PI / 2;


					
					 

					mesh.castShadow = true;
					mesh.receiveShadow = true;
					mesh.name = "THEMODEL"
					m_scene.add( mesh );
					m_scene_models.push(mesh);

					//TODO Check cams loaded
					m_application_state.num_models_loaded +=1
					console.log("INFO: Loading Model: DONE")
					var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
					document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";

					//precomputeRays()

				} );
			} 
			
			function loadModels()
			{
				m_application_state.num_models_to_load = 2
				loadModel(m_models_values[m_gui.gui_options.current_model]);

				const loader = new PLYLoader();
				 loader.load( './assets/arrow.ply', function ( geometry ) {
					const material = new THREE.MeshBasicMaterial( { color: 0xffffff} );
					m_vr_move_utils.guidesprite = new THREE.Mesh( geometry, material );
					console.log(m_vr_move_utils.guidesprite)
					m_application_state.num_models_loaded +=1
				})
				//m_scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

				//addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
				//addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 );


			}

			function toggleEnableCams()
			{
				m_cams_enabled = !m_cams_enabled;
				var arrayLength = m_camera_list.length;
				if(m_cams_enabled)
				{
					for (var i = 0; i < arrayLength; i++) {
					    m_camera_list[i].mesh.material.opacity = 0.1; 
					}
				}
				else
				{
					for (var i = 0; i < arrayLength; i++) {
					    m_camera_list[i].mesh.material.opacity = 0.0; 
					}
				}
			}
			function getScorePosition(index_cam)
			{
				var dist_max_aprox = (m_min_pos.distanceTo(m_max_pos))*2
				var dist = m_camera_list[index_cam].camera.position.distanceTo(m_camera.position)
				if(dist > dist_max_aprox)
					dist = dist_max_aprox;
				return (dist_max_aprox-dist)/dist_max_aprox;
				
			}
			function getScoreRotation(index_cam)
			{
				var direction1 = new THREE.Vector3();
				var direction2 = new THREE.Vector3();
				m_camera_list[index_cam].camera.getWorldDirection( direction1 );
				m_camera.getWorldDirection( direction2 );
				var dist = direction1.distanceTo(direction2);
				return dist/2;
				
			}
			function getScoreRays(index_cam, intersectsCamera, min_x, max_x, min_y, max_y)
			{
				//if(intersectsCamera.length == 0)
				//	return 1;
				/*var directionPhoto = new THREE.Vector3();
				m_camera_list[index_cam].getWorldDirection( directionPhoto );
				var raycasterPhoto =  new THREE.Raycaster(m_camera_list[index_cam].position, directionPhoto); 

				var intersectsPhoto = raycasterPhoto.intersectObjects( m_scene_models );  

				if(intersectsPhoto.length == 0)
					return 1;*/

				m_camera.updateProjectionMatrix();
				var count_inside_rays = 0

				for(var index_ray = 0; index_ray <m_camera_list[index_cam].rays.length; ++index_ray)
				{
					var projected = new THREE.Vector3();
					projected.copy(m_camera_list[index_cam].rays[index_ray])
					projected.project(m_camera)
					//console.log(projected)
					if(projected.x > min_x && projected.x < max_x && projected.y > min_y && projected.y < max_y)
					{
						//console.log("added " + index_cam)
						count_inside_rays = count_inside_rays +1
					}
						
				}
				console.log(m_camera_list[index_cam].name +" "+count_inside_rays)
				if(m_camera_list[index_cam].rays.length > 0)
					return count_inside_rays/m_camera_list[index_cam].rays.length
				else
					return 0
				//return intersectsPhoto[0].point.distanceTo(intersectsCamera[0].point);
				

			}
			
			
			function getScoreCam(index_cam, intersectsCamera, usingSelectionRectangle)
			{
				var distanceScore, orientationScore, raysScore;
				distanceScore = orientationScore = raysScore = 0;
				if(usingSelectionRectangle)
				{
					raysScore = getScoreRays(index_cam, intersectsCamera,m_selection_rectangle.startNDC.x,m_selection_rectangle.endNDC.x,m_selection_rectangle.startNDC.y,m_selection_rectangle.endNDC.y);

					var minNDCpoint = getNDCposFromWorld(m_camera_list[index_cam].camera, m_selection_rectangle.startWorld)
					var maxNDCpoint = getNDCposFromWorld(m_camera_list[index_cam].camera, m_selection_rectangle.endWorld)
					//console.log("minmax")
					//console.log(minNDCpoint)
					//console.log(maxNDCpoint)
					if(minNDCpoint != null && maxNDCpoint !=null)
					{
						if(minNDCpoint.x >maxNDCpoint.x)
						{
							var aux = minNDCpoint.x;
							minNDCpoint.x = maxNDCpoint.x;
							maxNDCpoint.x = aux;
						}
						if(minNDCpoint.y >maxNDCpoint.y)
						{
							var aux = minNDCpoint.y;
							minNDCpoint.y = maxNDCpoint.y;
							maxNDCpoint.y = aux;
						}
						m_camera_list[index_cam].sprite.material.uniforms.minSel.value = new THREE.Vector2((minNDCpoint.x+1)/2,(minNDCpoint.y+1)/2);
						m_camera_list[index_cam].sprite.material.uniforms.maxSel.value = new THREE.Vector2((maxNDCpoint.x+1)/2,(maxNDCpoint.y+1)/2);
					}
					else
					{
						m_camera_list[index_cam].sprite.material.uniforms.minSel.value = new THREE.Vector2(0.0,0.0);
						m_camera_list[index_cam].sprite.material.uniforms.maxSel.value = new THREE.Vector2(0.0,0.0);
					}
					
					return raysScore;
				}
				else
				{
					if(m_gui.gui_options.position)
						distanceScore = getScorePosition(index_cam);
					if(m_gui.gui_options.orientation)
						orientationScore = getScoreRotation(index_cam);
					if(m_gui.gui_options.projection)
						raysScore = getScoreRays(index_cam, intersectsCamera,-1,1,-1,1);

					m_camera_list[index_cam].sprite.material.uniforms.minSel.value = new THREE.Vector2(0.0,0.0);
					m_camera_list[index_cam].sprite.material.uniforms.maxSel.value = new THREE.Vector2(0.0,0.0);
					return distanceScore*m_gui.gui_options.position + orientationScore*m_gui.gui_options.orientation + raysScore*m_gui.gui_options.projection;
				}

				
			}
			

			function shiftCollectionSprites(collection,index, direction)
			{
				if(direction > 0)
				{
					var elem = collection.elems.shift()
					collection.elems.push(elem)
					//console.log("shifted1")
				} else
				{
					var elem = collection.elems.pop();
					collection.elems.unshift(elem);
					//console.log("shifted2")
				}
				
			}
			function updateCollectionsAnims(delta)
			{
				for(var i=0; i < m_current_candidates_collections.length; i++)
				{
					if(m_current_candidates_collections[i].animating !=0)
					{
						var value_shift = m_current_candidates_collections[i].animating
						if(m_current_candidates_collections[i].animating >0)
						{
							m_current_candidates_collections[i].animating = m_current_candidates_collections[i].animating - delta*2;
							if(m_current_candidates_collections[i].animating < 0)
								m_current_candidates_collections[i].animating = 0
						}
						else 
						{
							m_current_candidates_collections[i].animating = m_current_candidates_collections[i].animating + delta*2;
							if(m_current_candidates_collections[i].animating > 0)
								m_current_candidates_collections[i].animating = 0
						}
						if(m_current_candidates_collections[i].animating == 0)
							shiftCollectionSprites(m_current_candidates_collections[i],i, value_shift)
						var offset = m_current_candidates_collections[i].animating
						showCollection(m_current_candidates_collections[i].min, m_current_candidates_collections[i].max,i, [], true, offset)
					}
				}
				//m_application_state.
			}
			function singleLinkageClustering(num_clusters, num_elements_per_cluster)
			{


				m_current_candidates_collections = []
				for (var i = 0; i < m_current_candidates.length; i++) {

					var aux_collection_elem = {
						score: 0,
						elems: null,
						distances: null,
						animating: 0,
						min: null,
						max: null,
					}
					m_current_candidates_collections.push(aux_collection_elem);
				}
				for (var i = 0; i < m_current_candidates.length; i++) {
					var pair_elem_score = {
						elem: m_current_candidates[i].index,
						similitude: m_current_candidates[i].score,
					}
					m_current_candidates_collections[m_current_candidates[i].index].elems = [pair_elem_score]
					m_current_candidates_collections[m_current_candidates[i].index].distances = m_camera_list[m_current_candidates[i].index].similitudes.slice()
				}
				while(m_current_candidates_collections.length > num_clusters)
				{
					var mindist = 
					{
						c1: null,
						c2: null,
						dist: -1, //1 is the maximum distance allowed
					}
					for(var i = 0; i < m_current_candidates_collections.length; i++)
					{
						for(var j = i+1; j < m_current_candidates_collections[i].distances.length; j++)
						{
							if(m_current_candidates_collections[i].distances[j] > mindist.dist)
							{
								mindist.dist = m_current_candidates_collections[i].distances[j]
								mindist.c1 = i
								mindist.c2 = j
								//console.log("updated ("+i+","+j+") "+m_camera_list[m_current_candidates_collections[mindist.c1].elems[0].elem].name+ " with "+m_camera_list[m_current_candidates_collections[mindist.c2].elems[0].elem].name+ " -> "+mindist.dist+ " <-> " +m_camera_list[m_current_candidates_collections[mindist.c1].elems[0].elem].similitudes[mindist.c2])
							}
							if(mindist.dist==1)
								break;
						}
						if(mindist.dist==1)
								break;
					}
					
					if(mindist.c1 > mindist.c2)
					{
						var c_aux = mindist.c1
						mindist.c1 = mindist.c2
						mindist.c2 = c_aux
					}

					var newdistances = []
					for(var i=0; i < m_current_candidates_collections.length; i++)
					{
						var val1 = m_current_candidates_collections[mindist.c1].distances[i]
						var val2 = m_current_candidates_collections[mindist.c2].distances[i]
						if(i != mindist.c1 && i != mindist.c2)
							newdistances.push(Math.max(val1,val2))
					}
					newdistances.push(1)
					var aux_collection_elem = {
						score: 0,
						elems: m_current_candidates_collections[mindist.c1].elems.concat(m_current_candidates_collections[mindist.c2].elems),
						distances: newdistances.slice(),
						animating: 0,
						min: null,
						max: null,
					}
					//console.log("joined "+m_camera_list[m_current_candidates_collections[mindist.c1].elems[0].elem].name+ " with "+m_camera_list[m_current_candidates_collections[mindist.c2].elems[0].elem].name)
					m_current_candidates_collections.splice(mindist.c2,1)
					m_current_candidates_collections.splice(mindist.c1,1)
					for(var i = 0; i < m_current_candidates_collections.length; i++)
					{
						m_current_candidates_collections[i].distances.splice(mindist.c2,1)
						m_current_candidates_collections[i].distances.splice(mindist.c1,1)
						m_current_candidates_collections[i].distances.push(aux_collection_elem.distances[i])
					}
					m_current_candidates_collections.push(aux_collection_elem)
				}
				
				for(var i = 0; i < m_current_candidates_collections.length; i++)
				{
					m_current_candidates_collections[i].elems.sort(compareSimilitudes)
					var aux_array = []
					for(var j = 0; j < Math.min(num_elements_per_cluster,m_current_candidates_collections[i].elems.length); j++)
						aux_array.push(m_current_candidates_collections[i].elems[j].elem)
					if(m_current_candidates_collections[i].elems.length >0)
						m_current_candidates_collections[i].score = m_current_candidates_collections[i].elems[0].similitude
					m_current_candidates_collections[i].elems = aux_array
				}
				m_current_candidates_collections.sort(compareCandidates)
			}
			function basicClustering(num_clusters, num_elements_per_cluster, treshold)
			{
				var aux_candidate_list = []
				for (var i = 0; i < m_current_candidates.length; i++) {
					aux_candidate_list.push(m_current_candidates[i])
				}
				aux_candidate_list.sort(compareCanditateIndices)
				m_current_candidates_collections = []
				var current_collection_index = 0
				for (var i = 0; i < m_current_candidates.length; i++) {
					if(m_current_candidates[i].collection_index == -1 && m_current_candidates_collections.length < num_clusters)
					{
						var aux_collection_elem = {
							score: m_current_candidates[i].score,
							elems: [m_current_candidates[i].index],
							animating: 0,
							min: null,
							max: null,
						}
						m_current_candidates_collections.push(aux_collection_elem)
						m_current_candidates[i].collection_index=current_collection_index;
						var reached_treshold = false;
						var aux_index_capture = 0;
						while(!reached_treshold && aux_index_capture < m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered.length)
						{
							if(m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].similitude > treshold)
							{

								if(aux_candidate_list[m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index].collection_index == -1)
								{

									aux_candidate_list[m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index].collection_index = current_collection_index;

									if(m_current_candidates_collections[current_collection_index].elems.length < num_elements_per_cluster)
									{
										m_current_candidates_collections[current_collection_index].elems.push(m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index)
									}
									
								}
							}
							else
							{
								reached_treshold = true;
							}
							aux_index_capture = aux_index_capture+1;
						}
						current_collection_index = current_collection_index +1
					}
					else if(m_current_candidates_collections.length >= m_gui.gui_options.max_num_collections)
						break;
				}
			}
			function updateCandidateCollections()
			{
				if(m_gui.gui_options.clustering_method == 'single_linkage')
					singleLinkageClustering(m_gui.gui_options.max_num_collections, m_gui.gui_options.max_collection_size);
				else
					basicClustering(m_gui.gui_options.max_num_collections, m_gui.gui_options.max_collection_size, m_gui.gui_options.similitude_treshold);
				
				

			}
			function normalizeScores()
			{
				var biggest_score = m_current_candidates[0].score;
				for (var i = 0; i < m_current_candidates.length; i++) {
					m_current_candidates[i].score = m_current_candidates[i].score/biggest_score;
				}
			}
			function updateCandidates(usingSelectionRectangle)
			{
				console.log("INFO: Updating candidates...")
				var directionCamera = new THREE.Vector3();
				m_camera.getWorldDirection( directionCamera );
				var raycasterCamera =  new THREE.Raycaster(m_camera.position, directionCamera);    
				var intersectsCamera = raycasterCamera.intersectObjects( m_scene_models );  
				//console.log(intersectsCamera);

				var changed = false
				m_current_candidates = []
				var arrayLength = m_camera_list.length;

				if(usingSelectionRectangle)
				{
					var minWorldPoint = getWorldIntersectFromNDCxy(m_camera,m_selection_rectangle.startNDC,m_scene_models);
					var maxWorldPoint = getWorldIntersectFromNDCxy(m_camera,m_selection_rectangle.endNDC,m_scene_models);
					m_selection_rectangle.startWorld = minWorldPoint;
					m_selection_rectangle.endWorld = maxWorldPoint;
				}
				for (var i = 0; i < arrayLength; i++) {
					
				    //m_camera_list[i].material.opacity = 0.1; 
				    var scoreCam = getScoreCam(i, intersectsCamera, usingSelectionRectangle)
				    var elem = {
					    'index': i,
					    'score': scoreCam,
					    'collection_index': -1,
					};
					//console.log(m_camera_list[i].name+" "+i + " score: "+ scoreCam)
					if(isNaN(elem.score) )
						elem.score = 0;
					
					if(i >= m_current_candidates.length)
					{
						m_current_candidates.push(elem)
					}
				    else
				    {
				    	m_current_candidates[i] = elem
				    }
	
						
					
				}
				m_current_candidates.sort(compareCandidates)
				normalizeScores()
				updateCandidateCollections()
				if(m_current_capture_in_view_index == -1 && m_current_capture_in_view_index != m_current_candidates[0].index)
				{
					changeCaptureInView(m_current_candidates[0].index)
				}
				showCollections()
				//showCaptures(true)
				console.log("INFO: Updating candidates: DONE")
			}
			
			/*function changeMode()
			{
				if(m_camera_mode == "FLY")
					m_camera_mode = "ORBIT"
				else if(m_camera_mode == "ORBIT")
					m_camera_mode = "TRACK"
				else if(m_camera_mode == "TRACK")
					m_camera_mode = "FLY"
				else
					m_camera_mode = "FLY"
				initControls(m_camera_mode)
			}*/

			function resetCamera(mode)
			{
				if(m_camera)
				{
					m_camera_group.remove(m_camera)
				}
				if(m_cameraHelper)
				{
					m_scene.remove(m_cameraHelper)
				}

				console.log("RESET CAMERA")
				m_camera_capture_orto = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0, 10);

				//m_scene_capture.add(m_camera_capture_orto);

				m_camera_collections = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0, 10);
				//m_scene_collections.add(m_camera_collections);


				var start_x = m_models_values[m_gui.gui_options.current_model].pos_x_cam_start
				var start_y = m_models_values[m_gui.gui_options.current_model].pos_y_cam_start
				var start_z = m_models_values[m_gui.gui_options.current_model].pos_z_cam_start

				m_camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );
				
				m_camera.position.set( start_x,start_y,start_z );
				//camera.position.set( 3,0.15,3 );
				m_camera.name = "main_camera"
				//m_camera.up.set(0,0,1);
				//m_camera.layers.enable( 1 );
				
				

				m_camera_capture = new THREE.PerspectiveCamera( 50.5, 4000 / 2950, 0.1, 100 );
				m_camera_capture.position.set( start_x,start_y,start_z );
				m_cameraHelper = new THREE.CameraHelper(m_camera_capture);
				
				//camera.position.set( 3,0.15,3 );
				
				//m_camera_capture.up.set(0,0,1);



				if(mode == "ORBIT")
				{

					m_controls = new OrbitControls( m_camera, m_renderer.domElement );
					m_controls.minPolarAngle =  - Infinity; // radians
					m_controls.maxPolarAngle = Infinity; // radians
					m_controls.minDistance = 1;
					m_controls.maxDistance = 30;
					m_controls.minAzimuthAngle = - Infinity; // radians
					m_controls.maxAzimuthAngle = Infinity; // radians

					m_controls.target.set(-1*0.03,start_y,2*0.03)

					
					m_controls_secondary = new OrbitControls( m_camera_capture_orto, m_renderer.domElement );
					m_controls_secondary.minPolarAngle =  - Infinity; // radians
					m_controls_secondary.maxPolarAngle = Infinity; // radians
					m_controls_secondary.minDistance = 0;
					m_controls_secondary.maxDistance = 3;
					m_controls_secondary.minAzimuthAngle = - Infinity; // radians
					m_controls_secondary.maxAzimuthAngle = Infinity; // radians
					m_controls_secondary.enabled = false;

				}
				m_camera_group.position.set(0,0,0)

				m_camera_group.add(m_camera)
				m_scene.add(m_cameraHelper);
				//m_scene.add(m_camera_group);
			}
			function initControls(mode)
			{
				resetCamera(mode)
				m_scene.add(m_camera_group);
			}

			function clearSceneData()
			{
				//APL STATE
				m_application_state.state = AppStates.THREE_JS_INIT;
				m_application_state.num_cameras_loaded = 0;
				m_application_state.num_models_loaded = 0;
				m_application_state.three_js_inited = false;
				m_application_state.num_cameras_to_load = 0;
				m_application_state.num_models_to_load = 0;
				m_application_state.precomputed_file_loaded = false;
				m_application_state.precomputation_done = false;
				m_application_state.textures_loaded = false;
				m_application_state.count_precomputation_iterations = 0;
				m_application_state.capture_index_over_mouse = -1;
				m_application_state.transition_animation_step = 1.0;
				m_application_state.views_swaped = false;
				m_application_state.select_controls_enabled = false;
				m_application_state.need_to_update_auto_detect = false;
				m_application_state.inVR = false;
				

				m_min_pos = null;
				m_max_pos = null;

				m_has_any_secondary_capture = false;
				m_plane_image_secondary = null;

				m_camera_list = [];
				m_scene_models = [];
				m_current_candidates = [];
				m_current_candidates_collections = [];

				m_timer_update = 0;
				m_cams_enabled = false;
				m_current_capture_in_view_index = -1;
				m_capture_rays_need_recomputation = true;

				m_dragging = false;
				while(m_current_sprites_in_scene.children.length > 0){ 
				    m_current_sprites_in_scene.remove(m_current_sprites_in_scene.children[0]); 
				}
				

				while(m_scene.children.length > 0){ 
				    m_scene.remove(m_scene.children[0]); 
				}
				/*while(m_scene_collections.children.length > 0){ 
				    m_scene_collections.remove(m_scene_collections.children[0]); 
				}*/
				while(m_scene_capture.children.length > 0){ 
				    m_scene_capture.remove(m_scene_capture.children[0]); 
				}
				if(m_vr_panels_group)
				{
					while(m_vr_panels_group.children.length > 0){ 
					    m_vr_panels_group.remove(m_vr_panels_group.children[0]); 
					}
				}
				
				
			}
			function startSceneForModel()
			{

				clearSceneData()
				m_vr_panels_group = new THREE.Group();
				m_vr_panels_group.name = "vr_panels_group"
				m_camera_group = new THREE.Group()
				m_camera_group.name = "cameraGroup"
				m_camera_group.add(m_vr_panels_group)
				//m_scene.add(m_vr_panels_group)
				initVR();
				document.getElementById("loadingTextContainer").style.visibility = "visible";
				var xmlhttp = new XMLHttpRequest();
				xmlhttp.onreadystatechange = function() {
				    if (this.readyState == 4 && this.status == 200) {
				        var myObj = JSON.parse(this.responseText);
				        console.log("INFO: Capture info json loading... DONE")
				        loadCameras(myObj)
				        //setDefaultColorsCameras();
				    }
				};
				xmlhttp.open("GET", 'models/'+m_models_values[m_gui.gui_options.current_model].path+"/capture_info/cameraInfo.json", true);
				console.log("INFO: Capture info json loading...")
				xmlhttp.send();

				loadModels();
				initControls(m_camera_mode)
				m_gui.initInteractiveGroup(m_renderer, m_camera, m_scene, m_vr_panels_group, m_vr_move_utils)
				

				m_application_state.three_js_inited = true
				animate();
			}
			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 4 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );
						material.depthTest = false;
						material.transparent = true;
						var theline = new THREE.Line( geometry, material );
						theline.renderOrder = 1
						return theline

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}
			function getFloorFromPos(position)
			{
				var auxPos = new THREE.Vector3(position.x,100 ,position.z)
				var auxUp = new THREE.Vector3(0,-1,0)
				var raycasterFloor =  new THREE.Raycaster(auxPos, auxUp);    
				var intersectsFloor = raycasterFloor.intersectObjects( m_scene_models );  
				console.log(intersectsFloor)
				if(intersectsFloor.length > 0)
				{
					var minY = 1000;
					for(var i = 0; i < intersectsFloor.length; i++)
					{
						if(intersectsFloor[i].point.y < minY)
							minY = intersectsFloor[i].point.y
					}
					return minY+0.5
				}
				else
				{
					return m_models_values[m_gui.gui_options.current_model].vr_y
				}
			}
			function moveVRCam(offset)
			{
				m_camera_group.position.add(offset)
			}
			function initVR()
			{
				function onSelectStartLeft() {
					if(m_vr_move_utils.guidingController != null)
						return
					m_vr_move_utils.vrguiEnabled = true
					m_vr_panels_group.add(m_current_sprites_in_scene );
					m_vr_panels_group.position.copy(m_camera.position)
					m_vr_panels_group.rotation.copy(m_camera.rotation)
					m_timer_update = m_gui.gui_options.timer_recalc+1
					m_application_state.need_to_update_auto_detect = true;
					m_gui.enableVRgui()
				}
				function onSelectEndLeft() {
					if(m_vr_move_utils.vrguiEnabled)
						m_gui.disableVRgui()
					m_vr_panels_group.remove(m_current_sprites_in_scene );
					m_vr_move_utils.vrguiEnabled = false
				}
				function onSelectStartRight() {
					if(m_vr_move_utils.vrguiEnabled)
						return
				    m_vr_move_utils.guidingController = this;
				    m_vr_move_utils.guidelight.intensity = 1;
				    this.add(m_vr_move_utils.guideline);
				    m_scene.add(m_vr_move_utils.guidesprite);
				}

				function onSelectEndRight() {
				    if (m_vr_move_utils.guidingController === this) {

				        // first work out vector from feet to cursor

				        // feet position
				        const feetPos = m_renderer.xr.getCamera(m_camera).getWorldPosition(m_vr_move_utils.tempVec);
				        feetPos.y = m_camera_group.position.y;

				        // cursor position
				        const p = m_vr_move_utils.guidingController.getWorldPosition(m_vr_move_utils.tempVecP);
				        const v = m_vr_move_utils.guidingController.getWorldDirection(m_vr_move_utils.tempVecV);
				        v.multiplyScalar(6);
				        var offsety =  -m_camera_group.position.y;
				        const t = (-v.y+offsety  + Math.sqrt((v.y+offsety)**2 - 2*(p.y+offsety)*m_vr_move_utils.g.y))/m_vr_move_utils.g.y;
				        var cursorPos = positionAtT(m_vr_move_utils.tempVec1,t,p,v,m_vr_move_utils.g);
				        //cursorPos.y = m_camera_group.position.y+1
				        cursorPos.y = getFloorFromPos(cursorPos)
				        // Offset
				        const offset = cursorPos.addScaledVector(feetPos ,-1);

				        // Do the locomotion
				        //locomotion(offset);
				        moveVRCam(offset)
				        // clean up
				        m_vr_move_utils.guidingController = null;
				        m_vr_move_utils.guidelight.intensity = 0;
				        this.remove(m_vr_move_utils.guideline);
				        m_scene.remove(m_vr_move_utils.guidesprite);
				    }
				}
				m_controller1 = m_renderer.xr.getController( 0 );
				m_controller1.addEventListener( 'selectstart', onSelectStartRight );
				m_controller1.addEventListener( 'selectend', onSelectEndRight );
				m_controller1.addEventListener( 'connected', function ( event ) {
					this.add( buildController( event.data ) );

				} );
				m_controller1.addEventListener( 'disconnected', function () {
					this.remove( this.children[ 0 ] );

				} );
				m_camera_group.add( m_controller1 );

				m_controller2 = m_renderer.xr.getController( 1 );
				m_controller2.addEventListener( 'selectstart', onSelectStartLeft );
				m_controller2.addEventListener( 'selectend', onSelectEndLeft );
				m_controller2.addEventListener( 'connected', function ( event ) {
					this.add( buildController( event.data ) );

				} );
				m_controller2.addEventListener( 'disconnected', function () {
					this.remove( this.children[ 0 ] );

				} );
				m_camera_group.add( m_controller2 );

				const controllerModelFactory = new XRControllerModelFactory();

				m_controllerGrip1 = m_renderer.xr.getControllerGrip( 0 );
				m_controllerGrip1.add( controllerModelFactory.createControllerModel( m_controllerGrip1 ) );
				m_camera_group.add( m_controllerGrip1 );

				m_controllerGrip2 = m_renderer.xr.getControllerGrip( 1 );
				m_controllerGrip2.add( controllerModelFactory.createControllerModel( m_controllerGrip2 ) );
				m_camera_group.add( m_controllerGrip2 );
				
				
				//

				m_vr_move_utils.g = new THREE.Vector3(0,-9.8,0);
				m_vr_move_utils.tempVec = new THREE.Vector3();
				m_vr_move_utils.tempVec1 = new THREE.Vector3();
				m_vr_move_utils.tempVecP = new THREE.Vector3();
				m_vr_move_utils.tempVecV = new THREE.Vector3();

				// The m_vr_move_utils.guideline
				m_vr_move_utils.lineSegments=10;
				const lineGeometry = new THREE.BufferGeometry();
				m_vr_move_utils.lineGeometryVertices = new Float32Array((m_vr_move_utils.lineSegments +1) * 3);
				m_vr_move_utils.lineGeometryVertices.fill(0);
				const lineGeometryColors = new Float32Array((m_vr_move_utils.lineSegments +1) * 3);
				lineGeometryColors.fill(0.5);
				lineGeometry.setAttribute('position', new THREE.BufferAttribute(m_vr_move_utils.lineGeometryVertices, 3));
				lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineGeometryColors, 3));
				const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });
				m_vr_move_utils.guideline = new THREE.Line( lineGeometry, lineMaterial );

				// The light at the end of the line
				m_vr_move_utils.guidelight = new THREE.PointLight(0xffeeaa, 0, 2);

				// The target on the ground
				/*const guidespriteTexture = new THREE.TextureLoader().load('./assets/target.png');
				m_vr_move_utils.guidesprite = new THREE.Mesh(
				    new THREE.PlaneGeometry(0.3, 0.3, 1, 1),
				    new THREE.MeshBasicMaterial({
				        map: guidespriteTexture,
				        blending: THREE.AdditiveBlending,
				        color: 0x555555,
				        transparent: true
				    })
				);*/
				
					

			}
			function init() {


				m_models_values["doma"] = new ModelInfo("doma" ,"doma-interior_meshed_tex.png", "doma-interior_meshed_simplified.ply", 11.62, -0.137, 17.99, -1)
				m_models_values["pedret"] = new ModelInfo("pedret" ,"pedret-interior_meshed_tex.png", "pedret-interior_meshed_simplified.ply", 2.27, 0.58, -4.89,-1)
				m_models_values["solsona"] = new ModelInfo("solsona" ,"solsona_meshed_tex.jpg", "solsona_meshed_simplified.ply", 8.29, 0.73, 16.72,-1)
				m_container = document.createElement( 'div' );
				//const canvas = document.getElementById( 'canvas' );
				//canvas.width = 300 * window.devicePixelRatio;
				//canvas.height = 300 * window.devicePixelRatio;
				//const context = canvas.getContext( '2d' );
				document.body.appendChild( m_container );
				m_current_sprites_in_scene = new THREE.Group();
				m_current_sprites_in_scene.name = "imageCollectionGroup"
				m_current_sprites_in_scene.position.z = -4
				m_scene = new THREE.Scene();
				m_scene.background = new THREE.Color( 0x72645b );
				m_scene.fog = new THREE.Fog( 0x72645b, 2, 15 );

				m_scene_collections = new THREE.Scene();
				m_scene_collections.add(m_current_sprites_in_scene);
				m_scene_collections.background = null;

				m_scene_capture = new THREE.Scene();
				m_scene.background = new THREE.Color( 0x72645b );

				// m_renderer
				var canvas = document.getElementById("canvas");
				m_renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
				m_renderer.setPixelRatio( window.devicePixelRatio );
				m_renderer.setSize( window.innerWidth, window.innerHeight );
				m_renderer.outputEncoding = THREE.sRGBEncoding;
				m_renderer.setClearColor(0xffffff, 0);
				//m_renderer.shadowMap.enabled = true;
				m_renderer.autoClear = false; 
				m_renderer.xr.enabled = true;
				m_renderer.xr.setReferenceSpaceType( 'local' );
				m_renderer.setAnimationLoop( loop );
				m_render_target_secondary = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

				m_views[1].height = 0.3
				m_views[1].width = (m_views[1].height*(window.innerWidth / window.innerHeight))*(1/(window.innerWidth / window.innerHeight))
				m_views[1].left = 1.0-m_views[1].width

				m_container.appendChild( m_renderer.domElement );

				// stats

				m_stats = new Stats();
				m_container.appendChild( m_stats.dom );
				document.body.appendChild( VRButton.createButton( m_renderer, m_application_state ) );
				

				m_gui = new Gui();

				

				m_selection_rectangle.selectionBox = new SelectionBox( m_camera, m_scene );
				m_selection_rectangle.helper = new SelectionHelper( m_selection_rectangle.selectionBox, m_renderer, 'selectBox' );
				m_selection_rectangle.helper.element.hidden = true;






				window.addEventListener( 'resize', onWindowResize );
				
				document.addEventListener( 'mousewheel', onDocumentMouseWheel );
				document.addEventListener( 'pointerup', onDocumentPointerUp );
				document.addEventListener('pointermove', onDocumentPointerMove)
				document.addEventListener( 'pointerdown', onDocumentPointerDown );
				document.addEventListener("keydown", onDocumentKeyDown, false);
				document.addEventListener("keyup", event => {
				  if (/*event.isComposing || */event.keyCode === 17 && !m_application_state.views_swaped) {
				    m_application_state.select_controls_enabled = false;
					m_dragging = false

				    m_controls.enabled = true;

				    m_selection_rectangle.helper.element.hidden = true;
					/*m_canvas.setHeight(0);
					m_canvas.setWidth(0);*/
				  }
				});

				m_manager.onLoad = function()
				{
					//m_renderer.render( m_scene, camera );
				    console.log("INFO: DOMA_TEXTURE_LOADED");
				    animate()
				    
					m_application_state.textures_loaded = true
				}

				startSceneForModel();
			}

			function onWindowResize() {

				m_camera.aspect = window.innerWidth / window.innerHeight;
				m_camera.updateProjectionMatrix();

				m_renderer.setSize( window.innerWidth, window.innerHeight );



				m_views[1].height = 0.3
				m_views[1].width = (m_views[1].height*(window.innerWidth / window.innerHeight))*(1/(window.innerWidth / window.innerHeight))
				m_views[1].left = 1.0-m_views[1].width


				m_camera_capture_orto.left = window.innerWidth / - 2;
				m_camera_capture_orto.right =window.innerWidth / 2;
				m_camera_capture_orto.top = window.innerHeight / 2;
				m_camera_capture_orto.bottom = window.innerHeight / - 2;
				m_camera_capture_orto.updateProjectionMatrix();

				m_camera_collections.left = window.innerWidth / - 2;
				m_camera_collections.right =window.innerWidth / 2;
				m_camera_collections.top = window.innerHeight / 2;
				m_camera_collections.bottom = window.innerHeight / - 2;
				m_camera_collections.updateProjectionMatrix();
				showCollections()

			}
			function updateVR()
			{
				if (m_vr_move_utils.guidingController) {
			        // Controller start position
			        const p = m_vr_move_utils.guidingController.getWorldPosition(m_vr_move_utils.tempVecP);
			        //p.y = p.y+1
			        // Set Vector V to the direction of the controller, at 1m/s
			        const v = m_vr_move_utils.guidingController.getWorldDirection(m_vr_move_utils.tempVecV);
			        //v.y = v.y+1
			        // Scale the initial velocity to 6m/s
			        v.multiplyScalar(6);

			        // Time for tele ball to hit ground
			        var offsety =  -m_camera_group.position.y;
			        const t = (-v.y+offsety  + Math.sqrt((v.y+offsety)**2 - 2*(p.y+offsety)*m_vr_move_utils.g.y))/m_vr_move_utils.g.y;

			        const vertex = m_vr_move_utils.tempVec.set(0,0,0);
			        for (let i=1; i<=m_vr_move_utils.lineSegments; i++) {

			            // set vertex to current position of the virtual ball at time t
			            positionAtT(vertex,i*t/m_vr_move_utils.lineSegments,p,v,m_vr_move_utils.g);
			            m_vr_move_utils.guidingController.worldToLocal(vertex);
			            vertex.toArray(m_vr_move_utils.lineGeometryVertices,i*3);
			        }
			        m_vr_move_utils.guideline.geometry.attributes.position.needsUpdate = true;
			        
			        // Place the light and sprite near the end of the poing
			        positionAtT(m_vr_move_utils.guidelight.position,t*0.98,p,v,m_vr_move_utils.g);
			        positionAtT(m_vr_move_utils.guidesprite.position,t*0.98,p,v,m_vr_move_utils.g);
			    }
			}
			//https://www.google.com/maps/place/Sant+Esteve+de+la+Doma/@41.6862288,2.2778211,15z/data=!4m5!3m4!1s0x0:0xf0f2da56ced3387!8m2!3d41.6862318!4d2.277729?authuser=1
			//https://www.google.com/maps/place/MUSEU+DIOCESA+I+COMARCAL+DE+SOLSONA/@41.9941684,1.5193463,19.31z/data=!4m5!3m4!1s0x12a5ca1a2a0a3e57:0xeef7971a3fe002d3!8m2!3d41.9940063!4d1.5191797?authuser=1
			function exitVR()
			{
				m_vr_move_utils.lastFrameInVR = false

				//m_vr_panels_group.remove( m_current_sprites_in_scene );
				m_scene_collections.add(m_current_sprites_in_scene);
				resetCamera("ORBIT");
				showCollections()
				
			}
			function enterVR()
			{
				//m_vr_panels_group.add(m_current_sprites_in_scene );
				m_scene_collections.remove(m_current_sprites_in_scene);
				m_vr_move_utils.lastFrameInVR = true
				resetCamera("ORBIT");
				m_camera_group.position.y = m_models_values[m_gui.gui_options.current_model].vr_y
				showCollections()
				
			}
			function update()
			{

				const timer = Date.now() * 0.0005;
				const delta = m_clock.getDelta();
				requestAnimationFrame( animate );

				switch(m_application_state.state)
				{
					case AppStates.READY_TO_GO:
					{	
						var changeModel = m_gui.update()
						if(changeModel)
						{
							startSceneForModel()
							return
						}
						if(m_renderer.xr.isPresenting)
						{
							if(!m_vr_move_utils.lastFrameInVR)
								enterVR()
							updateVR()
						}
						else if(m_vr_move_utils.lastFrameInVR)
						{
							exitVR()
						}
						m_vr_panels_group.visible = m_renderer.xr.isPresenting;
						/*m_vr_panels_group.position.copy(m_camera.position)
						m_vr_panels_group.rotation.copy(m_camera.rotation)*/
						updateCollectionsAnims(delta)
						if(m_application_state.need_to_update_auto_detect)
							m_timer_update += delta

						if(!m_renderer.xr.isPresenting && m_old_pos_cam.distanceTo(m_camera.position) > 0.0001)
						{
							//console.log("changed!! " + m_old_pos_cam.x + " " +m_camera.position.x)
							m_timer_update = 0;
							m_application_state.need_to_update_auto_detect = true;
						}
							
						
						if(m_camera_mode != "FLY")
						{
							if(m_controls)
								m_controls.update();
							if(m_controls_secondary)
								m_controls_secondary.update();
						}
							
						m_stats.update();
						if(m_timer_update > m_gui.gui_options.timer_recalc)
						{
							//console.log("update")
							m_application_state.need_to_update_auto_detect = false
							m_timer_update = 0
							if(m_gui.gui_options.auto_score_enabled)
								updateCandidates(false);
						}
						if(m_camera_mode == "FLY")
						{
							m_controls.movementSpeed = 0.33 * 1;
							m_controls.update( delta );
						}
						m_old_pos_cam.copy(m_camera.position);

						m_scene_models[0].material.uniforms.showRedArea.value = m_gui.gui_options.red_area_enabled;
						break
					}


					case AppStates.THREE_JS_INIT:
					{
						if(m_application_state.three_js_inited)
						{
							m_application_state.state = AppStates.LOADING_MESHES
						}
						break
					}
					case AppStates.LOADING_MESHES:
					{
						if(m_application_state.num_models_to_load == m_application_state.num_models_to_load && m_application_state.num_cameras_loaded == m_application_state.num_cameras_to_load)
						{
							document.getElementById("loadingText").innerHTML = "Loading: 80%";
							m_application_state.state = AppStates.LOADING_TEXTURES
						}
						break
					}
					case AppStates.LOADING_TEXTURES:
					{
						if(m_application_state.textures_loaded)
						{

							m_application_state.state = AppStates.LOADING_PRECOMPUTED_DATA
							var loader = new THREE.FileLoader();
					        loader.load('models/'+m_models_values[m_gui.gui_options.current_model].path+'/capture_info/precomputedCameraData.txt', function ( data ) {
							        // output the text to the console
							        m_capture_rays_need_recomputation = DataLoader.loadPrecomputedFile(data, m_camera_list)
							        m_application_state.precomputed_file_loaded = true
									document.getElementById("loadingText").innerHTML = "Loading: 90%";
							});
							
						}
						break
					}
					case AppStates.LOADING_PRECOMPUTED_DATA:
					{
						if(m_application_state.precomputed_file_loaded)
						{
							if(m_capture_rays_need_recomputation)
							{
								
								precomputeCaptureInfo(m_num_rays_precomputation,m_num_rays_precomputation,m_application_state.count_precomputation_iterations)
							}
							else
							{
								m_application_state.state = AppStates.READY_TO_GO
								document.getElementById("loadingText").innerHTML = "";
								document.getElementById("loadingTextContainer").style.visibility = "hidden";
								console.log("INFO: System ready to go!")
							}
							
						}
							
						break
					}
				}
			}
			function loop()
			{
				update();
				render();
			}
			function animate() {
				
				//m_renderer.setAnimationLoop( loop );

			}
			function renderMainCamera(view_index, draw_border)
			{

				if(m_plane_image_secondary != null)
					m_plane_image_secondary.material.uniforms.showTexture.value = m_gui.gui_options.show_photo_enabled && m_gui.gui_options.show_view_enabled && m_gui.gui_options.show_camera_enabled;
				
				const left = Math.floor( window.innerWidth * m_views[view_index].left );
				const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
				const width = Math.floor( window.innerWidth * m_views[view_index].width );
				const height = Math.floor( window.innerHeight * m_views[view_index].height );

				if(!m_renderer.xr.isPresenting)
				{
					m_renderer.setViewport( left, bottom, width, height );
					m_renderer.setScissor( left, bottom, width, height );
					m_renderer.setScissorTest( true );


				} else
				{
					m_renderer.setScissorTest( false );
					/*m_renderer.xr.getCamera(m_camera).up.set(0,0,1);
					m_renderer.xr.getCamera(m_camera).cameras[0].up.set(0,0,1); 
					m_renderer.xr.getCamera(m_camera).cameras[1].up.set(0,0,1); */
					//m_camera.up.set(0,0,1);


				}

				if(draw_border)
				{
					m_renderer.setClearColor ( new THREE.Color(0x000000), 1.0 )
					m_renderer.clear();
					m_renderer.setViewport( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
					m_renderer.setScissor( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
				}
				m_camera.aspect = width / height;
				m_camera.updateProjectionMatrix();
				m_cameraHelper.visible = m_gui.gui_options.show_camera_enabled;
				m_renderer.render( m_scene, m_camera );
			}
			function renderSecondaryCamera(view_index, draw_border)
			{
				if(m_renderer.xr.isPresenting)
					return;
				m_cameraHelper.visible = false;
				const left = Math.floor( window.innerWidth * m_views[view_index].left );
				const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
				const width = Math.floor( window.innerWidth * m_views[view_index].width );
				const height = Math.floor( window.innerHeight * m_views[view_index].height );

				

				if(m_plane_image_secondary != null)
				{
					m_plane_image_secondary.material.uniforms.showTexture.value = m_gui.gui_options.show_photo_enabled;

					var frustumHeight = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
					var frustumWidth = frustumHeight * m_camera_capture.aspect;
					m_plane_image_secondary.scale.x = frustumWidth;
					m_plane_image_secondary.scale.y = frustumHeight;

					var old_rt = m_renderer.getRenderTarget()
					m_renderer.setRenderTarget(m_render_target_secondary)
					//m_camera_capture.aspect = width / height;
					m_camera_capture.updateProjectionMatrix();
					m_renderer.render( m_scene, m_camera_capture );
					m_renderer.setRenderTarget(null)

					m_plane_render_target.scale.x = window.innerHeight*m_camera_capture.aspect
					m_plane_render_target.scale.y = window.innerHeight


					//m_camera_capture_orto.aspect = width / height;
					//m_camera_capture_orto.updateProjectionMatrix();
				}

				if(draw_border)
				{
					m_renderer.setViewport( left-0.1, bottom, width+0.1, height+0.1 );
					m_renderer.setScissor( left-0.1, bottom, width+0.1, height+0.1 );
					m_renderer.setScissorTest( true );
				}
				m_renderer.setViewport( left, bottom, width, height );
				m_renderer.setScissor( left, bottom, width, height );
				m_renderer.setScissorTest( true );
				

				if(draw_border)
				{
					m_renderer.setClearColor ( new THREE.Color(0x000000), 1.0 )
					m_renderer.clear();
					m_renderer.setViewport( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
					m_renderer.setScissor( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
				}
				if(m_plane_image_secondary != null)
				{
					m_renderer.render( m_scene_capture, m_camera_capture_orto );
				}

				

				
			}
			function renderClusters(view_index)
			{
				if(m_renderer.xr.isPresenting)
					return;
				m_renderer.clearDepth();
				const left = Math.floor( window.innerWidth * m_views[view_index].left );
				const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
				const width = Math.floor( window.innerWidth * m_views[view_index].width );
				const height = Math.floor( window.innerHeight * m_views[view_index].height );

				m_renderer.setViewport( left, bottom, width, height );
				m_renderer.setScissor( left, bottom, width, height );
				m_renderer.render( m_scene_collections, m_camera_collections );
			}
			function render() {
				//if ( windowWidth != window.innerWidth || windowHeight != window.innerHeight ) {

				//	windowWidth = window.innerWidth;
				//	windowHeight = window.innerHeight;

				//m_renderer.setSize( window.innerWidth, window.innerHeight );

				//}
				m_cameraHelper.update();
				m_renderer.clear();
				if(m_scene_models.length >0)
					m_scene_models[0].material.uniforms.projectCapture.value = m_gui.gui_options.project_capture_enabled && m_plane_image_secondary != null;
				if(m_gui.gui_options.show_view_enabled && !m_application_state.select_controls_enabled)
				{
					if(m_application_state.views_swaped)
					{
						renderSecondaryCamera(0, false);
						renderMainCamera(1, true);
					}
					else
					{
						renderMainCamera(0, false);
						renderSecondaryCamera(1, true);
					}
				}
				else
				{
					if(m_application_state.views_swaped)
					{
						renderSecondaryCamera(2, false);
					}
					else
					{
						renderMainCamera(2, false);
					}
				}

				if(!m_application_state.select_controls_enabled)
					renderClusters(2);
				

			}
			function precomputeCaptureInfo(rays_x, rays_y, iteration)
			{
				

				DataLoader.precomputeRays(m_camera_list, rays_x, rays_y, iteration);
				m_application_state.count_precomputation_iterations = m_application_state.count_precomputation_iterations +1
				if(m_application_state.count_precomputation_iterations == m_camera_list.length)
				{
					m_capture_rays_need_recomputation = false
					DataLoader.precomputeCaptureSimilitude(m_camera_list);
					DataLoader.savePrecomputedFile(m_camera_list)
					m_application_state.precomputation_done = true
					m_application_state.count_precomputation_iterations = 0
				}
				
			}
			
			
		</script>

		
	</body>
</html>
